<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mah√© <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
--><!DOCTYPE html>


<html>
<head>
  <title>19. Adding to the Stdlib &mdash; Devguide</title>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">

  <meta name="hieroglyph-title" data-config-title>
  <meta name="hieroglyph-subtitle" data-config-subtitle>
  <meta name="hieroglyph-presenter" data-config-presenter>

  
  <link rel="stylesheet" media="all"
        href="_static/theme/css/default.css">
  <link rel="stylesheet" media="all"
        href="_static/theme/css/hieroglyph.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)"
        href="_static/theme/css/phone.css">

    

    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2015.08.08',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>

    <script data-main="_static/js/slides"
            src="_static/js/require-1.0.8.min.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    
    <link rel="top" title="Devguide" href="index.html" />
    <link rel="next" title="20. Changing the Python Language" href="langchanges.html" />
    <link rel="prev" title="18. Continuous Integration" href="buildbots.html" /> 
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

  

  
    <slide class="title-slide segue nobackground level-1" id="adding-to-the-stdlib">
    <hgroup>
      <h1>Adding to the Stdlib</h1>
    </hgroup>
    <article class="">
      <p>While the stdlib contains a great amount of useful code, sometimes you want
more than is provided. This document is meant to explain how you can get either
a new addition to a pre-existing module in the stdlib or add an entirely new
module.</p>
<p>Changes to pre-existing code is not covered as that is considered a bugfix and
thus is treated as a bug that should be filed on the <a class="reference external" href="http://bugs.python.org/">issue tracker</a>.</p>




    </article>
  </slide>  <slide class="level-2" id="adding-to-a-pre-existing-module">
    <hgroup>
      <h2>Adding to a pre-existing module</h2>
    </hgroup>
    <article class="">
      <p>If you have found that a function, method, or class is useful and you believe
it would be useful to the general Python community, there are some steps to go
through in order to see it added to the stdlib.</p>
<p>First is you should gauge the usefulness of the code. Typically this is done
by sharing the code publicly. You have a couple of options for this. One is to
post it online at the <a class="reference external" href="http://code.activestate.com/recipes/langs/python/">Python Cookbook</a>. Based on feedback or reviews of the
recipe you can see if others find the functionality as useful as you do.
A search of the issue tracker for previous suggestions related to the proposed
addition may turn up a rejected issue that explains why the suggestion will not
be accepted.
Another is to do a blog post about the code and see what kind of responses you
receive. Posting to python-list (see <a class="reference internal" href="communication.html#communication"><span>Following Python's Development</span></a> for where to find the
list and other mailing lists) to discuss your code also works. Finally, asking
on a specific <abbr title="special interest group">SIG</abbr> from mail.python.org or
python-ideas is also acceptable. This is not a required step but it is
suggested.</p>
<p>If you have found general acceptance and usefulness for your code from people,
you can open an issue on the <a class="reference external" href="http://bugs.python.org/">issue tracker</a> with the code attached as a
<a class="reference internal" href="patch.html#patch"><span>patch</span></a>. If possible, also submit a
<a class="reference internal" href="coredev.html#contributor-agreement"><span>contributor agreement</span></a>.</p>
<p>If a core developer decides that your code would be useful to the general
Python community, they will then commit your code. If your code is not picked
up by a core developer and committed then please do not take this personally.
Through your public sharing of your code in order to gauge community support
for it you at least can know that others will come across it who may find it
useful.</p>




    </article>
  </slide>  <slide class="level-2" id="adding-a-new-module">
    <hgroup>
      <h2>Adding a new module</h2>
    </hgroup>
    <article class="">
      <p>It must be stated upfront that getting a new module into the stdlib is very
difficult. Adding any significant amount of code to the stdlib increases the
burden placed upon core developers. It also means that the module somewhat
becomes &quot;sanctioned&quot; by the core developers as a good way to do something,
typically leading to the rest of the Python community to using the new module
over other available solutions. All of this means that additions to the stdlib
are not taken lightly.</p>




    </article>
  </slide>  <slide class="level-3" id="acceptable-types-of-modules">
    <hgroup>
      <h3>Acceptable Types of Modules</h3>
    </hgroup>
    <article class="">
      <p>Typically two types of modules get added to the stdlib. One type is a module
which implements something that is difficult to get right. A good example of
this is the <a class="reference external" href="https://docs.python.org/library/multiprocessing.html#module-multiprocessing" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">multiprocessing</span></code></a> package. Working out the various OS
issues, working through concurrency issues, etc. are all very difficult to get
right.</p>
<p>The second type of module is one that implements something that people
re-implement constantly. The <a class="reference external" href="https://docs.python.org/library/itertools.html#module-itertools" title="(in Python v2.7)"><code class="xref py py-mod docutils literal"><span class="pre">itertools</span></code></a> module is a good example of
this type as its constituent parts are not necessarily complex, but are used
regularly in a wide range of programs and can be a little tricky to get right.
Modules that parse widely used data formats also fall under this type of module
that the stdlib consists of.</p>
<p>While a new stdlib module does not need to appeal to all users of Python, it
should be something that a large portion of the community will find useful.
This makes sure that the developer burden placed upon core developers is worth
it.</p>




    </article>
  </slide>  <slide class="level-3" id="requirements">
    <hgroup>
      <h3>Requirements</h3>
    </hgroup>
    <article class="">
      <p>In order for a module to even be considered for inclusion into the stdlib, a
couple of requirements must be met.</p>
<p>The most basic is that the code must meet
<a class="reference internal" href="patch.html#patch"><span>standard patch requirements</span></a>. For code that has
been developed outside the stdlib typically this means making sure the coding
style guides are followed and that the proper tests have been written.</p>
<p>The module needs to have been out in the community for at least a year. Because
of Python's conservative nature when it comes to backwards-compatibility, when
a module is added to the stdlib its API becomes frozen. This means that a module
should only enter the stdlib when it is mature and gone through its
&quot;growing pains&quot;.</p>
<p>The module needs to be considered best-of-breed. When something is included in
the stdlib it tends to be chosen first for products over other third-party
solutions. By virtue of having been available to the public for at least a
year, a module needs to have established itself as (one of) the top choices by
the community for solving the problem the module is intended for.</p>
<p>The development of the module must move into Python's
infrastructure (i.e., the module is no longer directly maintained outside of
Python). This prevents a divergence between the code that is included in the
stdlib and that which is released outside the stdlib (typically done to provide
the module to older versions of Python). It also removes the burden of forcing
core developers to have to redirect bug reports or patches to an external issue
tracker and <abbr title="version control system">VCS</abbr>.</p>
<p>Someone involved with the development of the
module must promise to help maintain the module in the stdlib for two years.
This not only helps out other core developers by alleviating workload from bug
reports that arrive from the first Python release containing the module, but
also helps to make sure that the overall design of the module continues to be
uniform.</p>




    </article>
  </slide>  <slide class="level-3" id="proposal-process">
    <hgroup>
      <h3>Proposal Process</h3>
    </hgroup>
    <article class="">
      <p>If the module you want to propose adding to the stdlib meets the proper
requirements, you may propose its inclusion. To start, you should email
python-list or python-ideas to make sure the community in general would support
the inclusion of the module (see <a class="reference internal" href="communication.html#communication"><span>Following Python's Development</span></a>).</p>
<p>If the feedback from the community is positive overall, you will need to write
a <abbr title="Python enhancement proposal">PEP</abbr> for the module's inclusion. It
should outline what the module's overall goal is, why it should be included in
the stdlib, and specify the API of the module. See the <a class="reference external" href="http://www.python.org/dev/peps/">PEP index</a> for PEPs
that have been accepted before that proposed a module for inclusion.</p>
<p>Once your PEP is written, send it to python-ideas for basic vetting. Be
prepared for extensive feedback and lots of discussion (not all of it
positive). This will help make the PEP be of good quality and properly
formatted.</p>
<p>When you have listened to, responded, and integrated as appropriate the
feedback from python-ideas into your PEP, you may send it to python-dev. You
will once again receive a large amount of feedback and discussion. A PEP
dictator will be assigned who makes the final call on whether the PEP will be
accepted or not. If the PEP dictator agrees to accept your PEP (which typically
means that the core developers end up agreeing in general to accepting
your PEP) then the module
will be added to the stdlib once the creators of the module sign
<a class="reference internal" href="coredev.html#contributor-agreement"><span>contributor agreements</span></a>.</p>




    </article>
  </slide>


    <slide class="thank-you-slide segue nobackground">
    <article class="flexbox vleft auto-fadein">
      <h2>&lt;Thank You!&gt;</h2>
    </article>
    <p class="auto-fadein" data-config-contact>
      <!-- populated from slide_config.json -->
    </p>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>